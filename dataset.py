import os
import sys
import random

from abc import ABC  # abstract base class

import numpy as np
import pandas as pd
from pysat.formula import CNF
from pysat.solvers import Solver, NoSuchSolverError


class DatasetGenerator(ABC):
    """
    An abstract base class to provide a uniform interface for dataset generation
    """
    def generate_dataset(self, cnf_file, max_samples=1000, save_dataset=False):
        raise NotImplementedError

    def prepare_dataset(self, positives, negatives, save_path=None):
        """
        Creates the dataset from the positive and negative samples.
        Adds the labels, concatenates, shuffles, creates a
        dataframe and separate into inputs and labels
        :param positives:list
        :param negatives:list
        :param save_path: path to save the generated dataset (pickle format)
        :return: two dataframes: inputs and labels (data_x, data_y)
        """
        print(f'Preparing dataset.')

        # checks the validity of the samples
        if len(positives) == 0:
            print("No positives samples. Returning empty dataset")
            return [], []
        if len(negatives) == 0:
            print("No negative samples. Returning empty dataset")
            return [], []

        # appends the labels (1 to sat samples, 0 to unsat samples)
        for p in positives:
            p.append(1)
        for n in negatives:
            n.append(0)

        # concats the two lists and shuffles
        all_data = positives + negatives
        # random.seed(2) # uncomment to debug (otherwise each shuffle will give a different array)
        random.shuffle(all_data)

        # column names = [x1, x2, ..., xn, f] (each x_i is a variable and f is the label)
        input_names = [f'x{i}' for i in range(1, len(all_data[0]))]
        df = pd.DataFrame(all_data, columns=input_names + ['f'])
        if any(df.duplicated(input_names)):
            print('ERROR: there are duplicate inputs in the dataset. Returning empty.')
            return [], []

        # replaces negatives by 0 and positives by 1
        df.mask(df < 0, 0, inplace=True)
        df.mask(df > 0, 1, inplace=True)

        if df.isin([np.nan, np.inf, -np.inf]).values.any():
            print("ERROR: there are invalid samples in the dataset. Returning empty.")
            return [], []

        print(f'Generated dataset has {len(df)} instances, all unique.')

        if save_path is not None:
            print(f'Saving dataset to {save_path}.')
            df.to_pickle(save_path)

        # breaks into input features & label
        data_x = df.drop('f', axis=1)
        data_y = df['f']

        return data_x, data_y


class PySATDatasetGenerator(DatasetGenerator):
    def __init__(self, solver_name='Glucose3'):
        """
        Uses a SAT solver from pysat to generate positive samples (SAT witnesses).
        Unsat samples are generated by flipping one bit of a sat sample.

        All samples are shuffled and assembled into two dataframes.
        The first dataframe contains the binary (0/1) inputs.
        The second dataframe contains the corresponding binary label (0/1) for unsat/sat,
        respectively.

        :param solver_name: name of the solver to generate the positive instances
        """
        self.solver_name = solver_name

    def generate_dataset(self, cnf_file, max_samples=1000, save_dataset=False):
        """
        Generates a dataset from the boolean formula in the informed CNF file.
        Particularly, it enumerates all satisfying samples with a SAT solver.
        Then it generates the same number of unsat samples.
        Unsat samples are generated by flipping one bit of a sat sample.

        All samples are shuffled and assembled into two dataframes.
        The first dataframe contains the binary (0/1) inputs.
        The second dataframe contains the corresponding binary label (0/1) for unsat/sat,
        respectively.

        :param cnf_file: path to the file in CNF (Dimacs) format (see https://people.sc.fsu.edu/~jburkardt/data/cnf/cnf.html)
        :param max_samples: maximum number of samples, half of them will be positive, half negative
        :return: tuple with 2 dataframes: inputs and labels
        """

        print(f'Reading boolean formula from {cnf_file}.')
        formula = CNF(from_file=cnf_file)

        # num_vars = formula.nv
        unsat_list = []

        print(f'Finding satisfiable assignments with {self.solver_name}')
        try:
            with Solver(name=self.solver_name, bootstrap_with=formula) as solver:

                # for each positive (sat) instance, flip a literal to generate a negative (unsat) instance

                # generates the satisfying instances by querying the solver
                sat_list = []
                for i, solution in enumerate(solver.enum_models()):
                    sat_list.append(solution)
                    if i+1 >= max_samples / 2:  # adds 1 to index as it starts at zero
                        print(f"Limit number of {max_samples/2} positive samples reached.")
                        break

                print(f'Found {len(sat_list)} sat instances.')
                if len(sat_list) == 0:
                    print('WARNING: No sat instance found, returning empty dataset.')
                    return [], []

                print('Generating the same number of unsat instances.')

                # transforming each sat instance into tuple eases the generation of negative instances
                sat_set = set([tuple(s) for s in sat_list])  # set is much quicker to verify an existing instance

                for assignment in sat_list:
                    for i, literal in enumerate(assignment):
                        tentative_unsat = list(assignment)
                        tentative_unsat[i] = -tentative_unsat[i]  # negating one literal
                        if tuple(tentative_unsat) not in sat_set:
                            unsat_list.append(tentative_unsat)
                            break  # goes on to next assignment
                        # print(f'negated {i}-th')
        except NoSuchSolverError as e:
            print(f'ERROR: no solver named "{self.solver_name}" was found. '
                  f'Please use one of the names in '
                  f'https://pysathq.github.io/docs/html/api/solvers.html#pysat.solvers.SolverNames'
                  f', such as Glucose3, for example. Exiting.')
            sys.exit(0)

        # uncomment below to test duplicates
        # sat_list.append(sat_list[0])
        return self.prepare_dataset(sat_list, unsat_list)


class UnigenDatasetGenerator(DatasetGenerator):
    def __init__(self, tmp_dir='/tmp/unigen'):
        """
        Initializes the UnigenDatasetGenerator
        :param tmp_dir: working dir of the sample generator unigen
        """
        self.tmp_dir = tmp_dir
        self.formula = None  # is assigned in generated_dataset

    def generate_dataset(self, cnf_file, max_samples=1000, save_dataset=False):
        """
        Uses Unigen2 (https://bitbucket.org/kuldeepmeel/unigen) to generate a dataset
        :param cnf_file:
        :param max_samples:
        :return:
        """
        # makes sure that unigen working dir exists for positive and negative samples
        pos_dir = os.path.join(self.tmp_dir, 'positives')
        neg_dir = os.path.join(self.tmp_dir, 'negatives')
        os.makedirs(pos_dir, exist_ok=True)
        os.makedirs(neg_dir, exist_ok=True)

        # gets f from the cnf file
        f = CNF(cnf_file)
        self.formula = f

        print("Generating positive instances.")
        self.run_unigen(cnf_file, pos_dir, max_samples)
        # the file with the positive samples is pos_dir/cnf_file_0.txt
        cnf_name = os.path.splitext(os.path.basename(cnf_file))[0]
        positives = self.recover_samples(os.path.join(pos_dir, f'{cnf_name}_0.txt'))
        print(f'Sampled {len(positives)} unique positive instances')

        print("Generating negative instances.")
        # limits  #negatives by #positives or max_samples/2
        negatives = self.generate_negative_samples(f, min(len(positives), max_samples // 2))
        print(f'Sampled {len(negatives)} negative instances')

        # if the user requested to save, the dataset file will be cnf_file.pkl
        ds_path = f'{os.path.basename(cnf_file)}.pkl' if save_dataset else None

        return self.prepare_dataset(positives, negatives, ds_path)

    def generate_negative_samples(self, f, max_samples, max_attempts=100000):
        """
        Generates negative samples of a boolean formula f uniformly at random
        :param f:
        :param max_samples: maximum number of samples to generate
        :param max_attempts: maximum number of attempts (prevents infinite loop in case of difficult negative samples)
        :return:
        """
        negatives = set()  # a set prevents the existence of duplicates
        attempts = 0
        while len(negatives) < max_samples and attempts < max_attempts:
            attempts += 1

            # generates a random assignment and tests if it satisfies f
            # the candidate follows the DIMACS format (i or -i for asserted/negated variable i)
            candidate = [x * random.choice([-1, 1]) for x in range(1, f.nv + 1)]  # 1 to n+1 because literal indexes start at 1

            # avoids generating duplicate instances
            if tuple(candidate) in negatives:
                # print(f'duplicate {candidate} detected')
                continue

            # if any clause has all literals disagreeing in sign with the assignment, the candidate falsifies f
            if any([all([candidate[abs(l) - 1] * l < 0 for l in clause]) for clause in f.clauses]):
                # print(f'{candidate} evaluated to false, adding to negatives')
                negatives.add(tuple(candidate))

        # transforms the set of tuples into a list of lists
        neg_list = list([list(x) for x in negatives])

        if attempts == max_attempts:
            print(f'WARNING: maximum #attempts ({max_attempts}) to generate ~f samples reached.')

        return neg_list

    def recover_samples(self, samples_path):
        """
        Reads the file generated by unigen to extract the satisfying assignments there
        :param samples_path:
        :return:
        """
        if not os.path.exists(samples_path):
            print(f'Samples file {samples_path} does not exist. Returning empty.')
            return []

        print(f'Recovering samples from {samples_path}')
        samples = []
        with open(samples_path) as sample_file:
            for line in sample_file.readlines():
                # format of each line: v1 2 ... N 0:M, where 1 2 ... N are the variables (asserted or negated)
                # strips, discards the first char (v), splits with space, discards the last part (0:M)
                # str_assignments is an array with the variables (asserted or negated)
                str_assignments = line.strip()[1:].split(' ')[:-1]
                # appends this assignment to the list of positive (witnesses for f)
                # the if skips blank lines
                if len(str_assignments) > 0:
                    sample = [int(x) for x in str_assignments]
                    if len(sample) < self.formula.nv: # only indep. support has been assigned
                        sample = self.fill_dependent_variables(sample)

                    samples.append()
        return samples

    def run_unigen(self, cnf_file, out_dir, max_samples):
        """
        Calls unigen script to generate SAT witnesses for the formula in cnf_file
        The witnesses will be located at out_dir
        :param cnf_file:
        :param out_dir:
        :param max_samples:
        :return:
        """
        import subprocess

        print('Calling unigen.')
        # saves the current dir, the input name (filename w/o extension) and
        # absolute path to the input
        current_dir = os.getcwd()
        cnf_abspath = os.path.abspath(cnf_file)

        '''
        unigen is called with: python UniGen2.py [options] cnf_file output
        We'll call python from the command line as it is not straightforward to 
        import unigen and instantiate its parameters directly
        '''

        os.chdir('unigen')
        # calls unigen on the formula from cnf_file
        ret_code = subprocess.call(
            f'python UniGen2.py -samples={max_samples // 2} -runIndex=0 '
            f'{cnf_abspath} {out_dir}'.split(' ')  # split because call accepts an array
        )
        if ret_code != 0:
            print("WARNING! there has been some error with unigen's execution. "
                  "Please check the output above.")
        os.chdir(current_dir)

    def fill_dependent_variables(self, sample):
        """
        Fills the dependent variables of an incomplete sample
        :param sample:
        :return:
        """
        # known support: dict(variable -> value) --- value > 0 == True
        known_support = {abs(literal): literal for literal in sample}

        # puts clauses in set of tuples to ease removal
        clauses = set([tuple(c) for c in self.formula.clauses])

        while len(known_support) < self.formula.nv:
            # all clauses must evaluate to true
            for clause in clauses:
                # if all variables are in the known support, remove the clause & go to next
                if all([abs(l) in known_support for l in clause]):
                    clauses.remove(clause)
                    continue

                # if known variables already make the clause true, ignore & go to next
                clause_solved = False
                missing_literals = []
                for l in clause:
                    if l not in known_support:
                        missing_literals.append(l)
                    elif known_support[l] * l > 0:  # if variable value & literal agree on sign, it evaluates to True
                        clause_solved = True

                # if clause is not solved and only 1 literal is missing, determine its value
                if not clause_solved and len(missing_literals) == 1:
                    # the corresponding value of the variable is the literal itself
                    known_support[abs(missing_literals[0])] = missing_literals[0]

            # returns the full assignment with variables sorted according to their index (abs. value)
            return sorted(known_support.values(), key=lambda x: abs(x))
